----

----

# 数字类型

>   数字并不是一个真正的对象类型,而是一组类似类型的分类

## 整数

>   整数包含正数,负数和0,同时允许使用二进制, 八进制, 十六进制字面量表示

````python
# 整数类型
# -521, 521, 0, 无群小~无群大(只和内存有关)

# 向内存申请一空闲内存单元存储521并将变量名dec_num指向此内存单元的地址
# 十进制
>>> dec_num = 521
# 二进制
>>> bin_num = 0b1000001001
# 八进制
# for Python2
>>> oct_num = 01011
# for Python3
>>> oct_num = 0o1011
# 16进制
>>> hex_num = 0x209
>>> type(dec_num), type(bin_num), type(oct_num), type(hex_num)
(<type 'int'>, <type 'int'>, <type 'int'>, <type 'int'>)
# 查看变量dec_num类型的定义
>>> help(dec_num)
# 查看变量dec_num类型的属性和方法
>>> dir(dec_num)
````

### 对象创建

```python
# 方式一: 通过字面量形式创建
>>> 521
521

# 方式二: 通过类型创建
"""
int(x=0) -> int or long
int(x, base=10) -> int or long
"""
>>> int('521')
521
>>> int('1000001001', base=2)
521
>>> int('1011', base=8)
521
>>> int(521)
521
>>> int('200', base=16)
521
```

### 进制转换

>   核心思想就是D进制满D向左进1位,也就是说从右到左的基数依次为d^0^~d^n^

```bash
# 十进制, 满十进一位
> 521
= 1 * 1    + 2 * 10   + 5 * 100
= 1*10^0 + 2*10^1 + 5*10^2

# 二进制, 满二进一位
> 1000001001
= 1*2^0 + 0*2^1 + 0*2^2 + 1*2^3 + 0*2^4 + 0*2^5 + 0*2^6 + 0*2^7 + 0*2^8 + 1*2^9

# 八进制, 满八进一位
> 1011
= 1*8^0 + 1*8^1 + 0*8^2 + 1*8^3

# 16进制, 满16进一位
# 0 1 2 3 4 5 6 7 8 9 a(10) b(11) c(12) d(13) e(14) f(15)
> 209
= 9*16^0 + 0*16^1 + 2*16^2
```

### 精度扩展

>   Python2中会自动将大整数转换为长整型数并且以后缀l/L标识,但Python3中则隐藏了此默认行为

```python
>>> import sys

# for Python2
>>> sys.maxint + 1
9223372036854775808L

# for Python3
>>> sys.maxsize + 1
9223372036854775808
```

##  浮点数

>   浮点数为包含小数部分的数字,同时允许使用单点,科学计数法的字面量表示

```python
# 浮点数类型
# 5.21, 5., 5.21e2/5.21E2, 512e-2/512E-2

# 向内存申请一空闲内存单元存储5.21并将变量名f指向此内存单元的地址
>>> f = 5.21
>>> type(f)
<type 'float'>
# 查看变量f类型的定义
>>> help(f)
# 查看变量f类型的属性和方法
>>> dir(f)
```

### 对象创建

```python
# 方式一: 通过字面量形式创建
>>> 5.21
5.21

# 方式二: 通过类型创建
"""
float(x) -> floating point number
"""
>>> float(521)
521.0
```

### 精度丢失

>   浮点数转换二进制时可能出现死循环,CPU为了阻止此默认行为而导致的精度丢失是必然行为且不可控

```python
# 问题: 浮点数运算为何会丢失精度?
>>> 0.2 + 0.4
0.6000000000000001

# 模拟: 浮点数转二进制通过不断乘2直至小数部分为0,然后倒序组合整数部分与0.组合即为二进制
"""
部分浮点数如0.2,0.4会导致转换过程死循环,CPU会在计算到固定位数时中断此行为,所以就出现了精度丢失的问题
"""
# 0.2转换为二进制模拟 0.0011...
0.2 * 2 = 0.4,整数部分为0,小数部分为0.4
0.4 * 2 = 0.8,整数部分为0,小数部分为0.8
0.8 * 2 = 1.6,整数部分为1,小数部分为0.6
0.6 * 2 = 1.2,整数部分为1,小数部分为0.2   # 无限循环

# 0.4转换为二进制模拟 0.0110...
0.4 * 2 = 0.8 整数部分为0,小数部分为0.8
0.8 * 2 = 1.6 整数部分为1,小数部分为0.6
0.6 * 2 = 1.2 整数部分为1,小数部分为0.2
0.2 * 2 = 0.4 整数部分为0,小数部分为0.4   # 无限循环


# 解决: 使用decimal.Decimal类
"""
优点: 从代码层面模拟CPU算法支持精确到任意精度
缺点: 提升精度的同时会带来性能上的损耗
"""
>>> from decimal import Decimal
>>> Decimal('0.2') + Decimal('0.4')
Decimal('0.6')
```

## 复数

>   复数为包含实部和虚部(以j或J结尾)的数字

```python
# 复数类型
# 100j

# 向内存申请一空闲内存单元存储0+100j并将变量名c指向此内存单元的地址
>>> c = 0+100j
>>> type(c)
<type 'complex'>
# 查看变量c类型的定义
>>> help(c)
# 查看变量c类型的属性和方法
>>> dir(c)
```

### 创建对象

```python
# 方式一: 通过字面量形式创建
>>> 0 + 100j
100j

# 方式二: 通过类型创建
"""
complex(real[, imag]) -> complex number
"""
>>> complex(0, 100)
100j
```

# 数字操作

:point_right: 混合操作符优先级问题可通过括号()提升优先级解决

:point_right: 混合类型的转换以复杂度为基准,会自动转换至复杂度最高的类型

## 赋值运算

>   向内存申请一空闲内存单元存储数字然后将变量名指向此内存单元,至此可通过变量名操作此内存单元数据

```python
>>> x = 521
>>> y = 52.1
>>> z = 5.21
```

## 比较运算

>   结果总是被隐式转换为布尔对象

```python
# 值比较
# 小于
>>> y < x
True

# 小于等于
>>> x <= x
True

# 大于
>>> x > y
True

# 大于等于
>>> x >= y
True

# 等于
>>> x == x
True

# 不等于
# for Python2
>>> x != y
True
>>> x <> y
True
# for Python3
>>> x != y
True

# 地址比较
>>> id(x), id(521)
(140428868352096, 140428868352072)
>>> x is 521
False
```

:point_right: 比较操作符支持连续使用如5.21 < 52.1 < 521等同于5.21 < 52.1 and 52.1 < 521

## 数学运算

>   结果总是隐式转换为复杂类型

```python
# 正负
>>> +x
521
>>> -x
-521

# 加法
>>> x + 0
521

# 减法
>>> x - 21
500

# 乘法
>>> z * 100
521.0

# 除法
"""
兼容特性: from __future__ import division
"""
# Python2中对于包含小数使用真除法(保留小数部分,最终为小数)
>>> x / 100.
5.21
# Python3中对于包含小数使用真除法(保留小数部分,最终为小数)
>>> x / 100.
5.21
# Python2中对于全整数使用传统除法(保留整数部分,最终为整数)
>>> x / 100
5
# Python3中对于全整数使用真除法(保留小数部分,最终为小数)
>>> x / 100
5.21
# Python2中对于包含小数使用地板除(保留整数部分,最终为小数)
# Python3中对于包含小数使用地板除(保留整数部分,最终为小数)
>>> x // 100.
5.0
# Python2中对于全整数使用地板除(保留整数部分,最终为整数)
# Python3中对于全整数使用地板除(保留整数部分,最终为整数)
>>> x // 100
5

# 取模
>>> x % 2
1

# 乘方
>>> z * 10 ** 2
521.0
```

## 逻辑运算

```python
# 与, 都为真为真
>>> x and y
52.1

# 或, 一个真即真
>>> x or y
521

# 非,总是隐式转换为布尔对象
>>> not x
False
```

## 位移运算

```python
>>> bin(x)
'0b1000001001'

# 异或
"""
规则: 0变为1,1变为0
1000001001
----------
0111110110
"""

# 左移
>>> bin(x << 2)
'0b100000100100'

# 右移
>>> bin(x >> 2)
'0b10000010'

# 位与
"""
规则: 都为1为1,否则为0
100000100100
000010000010
------------
000000000000
"""
>>> 0b100000100100 & 0b10000010
0

# 位或
"""
规则: 存在1为1,否则为0
100000100100
000010000010
------------
100010100110
"""
>>> 0b100000100100 | 0b10000010
2214
```



# 相关函数

| 函数                              | 说明                              |
| --------------------------------- | --------------------------------- |
| bin(number)                       | 将整数转换为二进制字符串          |
| oct(number)                       | 将整数转换为八进制字符串          |
| int(x, base=10)                   | 将base进制字符串x转换为十进制整数 |
| hex(number)                       | 将整数转换为十六进制字符串        |
| eval(source[, globals[, locals]]) | 将字符串source作为有效代码解释    |
|                                   |                                   |



# 相关模块

## Python2

| 点击                     | 描述 |
| ------------------------ | ---- |
| :point_right: [math](#)​  |      |
| :point_right: [cmath](#)​ |      |



## Python3

